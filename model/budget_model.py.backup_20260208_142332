from __future__ import annotations
import sqlite3
from dataclasses import dataclass

from model.undo_redo_model import UndoRedoModel

# Reservierte Namen die nicht als Kategorie verwendet werden dÃ¼rfen
RESERVED_CATEGORY_NAMES = [
    "BUDGET-SALDO",
    "ðŸ“Š BUDGET-SALDO",
    "TOTAL",
    "SUMME",
    "__TOTAL__",
    "__SALDO__"
]

@dataclass(frozen=True)
class BudgetRow:
    year: int
    month: int
    typ: str
    category: str
    amount: float

class BudgetModel:
    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self.undo = UndoRedoModel(conn)
        # Bereinige fehlerhafte EintrÃ¤ge beim Start
        self._cleanup_reserved_categories()

    def _is_reserved_category(self, category: str) -> bool:
        """PrÃ¼ft ob ein Kategoriename reserviert ist."""
        if not category:
            return False
        cat_upper = str(category).upper().strip()
        for reserved in RESERVED_CATEGORY_NAMES:
            if reserved.upper() in cat_upper or cat_upper in reserved.upper():
                return True
        # Auch Emoji-Versionen prÃ¼fen
        if "ðŸ“Š" in category or "SALDO" in cat_upper:
            return True
        return False

    def _cleanup_reserved_categories(self):
        """Entfernt fehlerhafte reservierte Kategorien aus der Datenbank (einmalig beim Start)."""
        try:
            for reserved_name in RESERVED_CATEGORY_NAMES:
                self.conn.execute("DELETE FROM budget WHERE category = ? OR category LIKE ?",
                           (reserved_name, f"%{reserved_name}%"))
            self.conn.commit()
        except Exception:
            pass  # Fehler beim Cleanup ignorieren (z.B. wenn Tabelle nicht existiert)

    def set_amount(self, year:int, month:int, typ:str, category:str, amount:float) -> None:
        # SCHUTZ: Reservierte Kategorien blockieren
        if self._is_reserved_category(category):
            # Stiller Fehler - keine Exception werfen um UI nicht zu crashen
            return
        
        old = self.conn.execute(
            "SELECT * FROM budget WHERE year=? AND month=? AND typ=? AND category=?",
            (int(year), int(month), typ, category),
        ).fetchone()

        self.conn.execute(
            "INSERT INTO budget(year,month,typ,category,amount) VALUES(?,?,?,?,?) "
            "ON CONFLICT(year,month,typ,category) DO UPDATE SET amount=excluded.amount",
            (int(year), int(month), typ, category, float(amount)),
        )
        self.conn.commit()

        new = self.conn.execute(
            "SELECT * FROM budget WHERE year=? AND month=? AND typ=? AND category=?",
            (int(year), int(month), typ, category),
        ).fetchone()

        op = "INSERT" if old is None else "UPDATE"
        self.undo.record_operation(
            "budget",
            op,
            dict(old) if old else None,
            dict(new) if new else None,
        )

    def get_matrix(self, year:int, typ:str) -> dict[str, dict[int,float]]:
        cur=self.conn.execute(
            "SELECT month, category, amount FROM budget WHERE year=? AND typ=?",
            (int(year), typ),
        )
        matrix={}
        for r in cur.fetchall():
            cat = r["category"]
            # SCHUTZ: Reservierte Kategorien herausfiltern
            if self._is_reserved_category(cat):
                continue
            matrix.setdefault(cat, {})[int(r["month"])]=float(r["amount"])
        return matrix

    def years(self) -> list[int]:
        cur=self.conn.execute("SELECT DISTINCT year FROM budget ORDER BY year")
        return [int(r[0]) for r in cur.fetchall()]

    def seed_year_from_categories(self, year:int, typ:str, categories:list[str], amount:float=0.0) -> None:
        cur=self.conn.cursor()
        for cat in categories:
            # SCHUTZ: Reservierte Kategorien Ã¼berspringen
            if self._is_reserved_category(cat):
                continue
            for m in range(1,13):
                cur.execute(
                    "INSERT OR IGNORE INTO budget(year,month,typ,category,amount) VALUES(?,?,?,?,?)",
                    (int(year), int(m), typ, cat, float(amount)),
                )
        self.conn.commit()

    def delete_category_for_year(self, year:int, typ:str, category:str) -> None:
        rows = self.conn.execute(
            "SELECT * FROM budget WHERE year=? AND typ=? AND category=?",
            (int(year), typ, category),
        ).fetchall()
        # Undo/Redo: mehrere DELETEs als eine Gruppe behandeln
        group = self.undo.new_group_id() if rows else None

        self.conn.execute(
            "DELETE FROM budget WHERE year=? AND typ=? AND category=?",
            (int(year), typ, category),
        )
        self.conn.commit()

        for r in rows:
            self.undo.record_operation("budget", "DELETE", dict(r), None, group_id=group)

    def delete_category_all_years(self, typ:str, category:str) -> None:
        rows = self.conn.execute(
            "SELECT * FROM budget WHERE typ=? AND category=?",
            (typ, category),
        ).fetchall()
        # Undo/Redo: mehrere DELETEs als eine Gruppe behandeln
        group = self.undo.new_group_id() if rows else None

        self.conn.execute(
            "DELETE FROM budget WHERE typ=? AND category=?",
            (typ, category),
        )
        self.conn.commit()

        for r in rows:
            self.undo.record_operation("budget", "DELETE", dict(r), None, group_id=group)

    def rename_category(self, typ:str, old_name:str, new_name:str) -> None:
        # SCHUTZ: Neue Kategorie darf nicht reserviert sein
        if self._is_reserved_category(new_name):
            return
        
        rows = self.conn.execute(
            "SELECT * FROM budget WHERE typ=? AND category=?",
            (typ, old_name),
        ).fetchall()
        # Undo/Redo: mehrere UPDATEs als eine Gruppe behandeln
        group = self.undo.new_group_id() if rows else None

        self.conn.execute(
            "UPDATE budget SET category=? WHERE typ=? AND category=?",
            (new_name, typ, old_name),
        )
        self.conn.commit()

        for r in rows:
            old_dict = dict(r)
            new_dict = dict(r)
            new_dict["category"] = new_name
            self.undo.record_operation("budget", "UPDATE", old_dict, new_dict, group_id=group)

    def sum_by_typ(self, year:int, month:int) -> dict[str,float]:
        cur = self.conn.execute(
            "SELECT typ, SUM(amount) AS s FROM budget WHERE year=? AND month=? GROUP BY typ",
            (int(year), int(month)),
        )
        return {str(r["typ"]): float(r["s"] or 0.0) for r in cur.fetchall()}

    def sum_year_by_typ(self, year:int, typ: str|None=None) -> dict[str,float]:
        if typ is None:
            cur = self.conn.execute(
                "SELECT typ, SUM(amount) AS s FROM budget WHERE year=? GROUP BY typ",
                (int(year),),
            )
            return {str(r["typ"]): float(r["s"] or 0.0) for r in cur.fetchall()}
        else:
            cur = self.conn.execute(
                "SELECT SUM(amount) AS s FROM budget WHERE year=? AND typ=?",
                (int(year), typ),
            )
            row = cur.fetchone()
            return {typ: float(row["s"] or 0.0) if row else 0.0}

    def sum_by_category(self, year: int|None = None, month: int|None = None, typ: str|None = None) -> dict[str,float]:
        if year is None and month is None:
            if typ is None:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget GROUP BY category ORDER BY ABS(s) DESC"
                )
            else:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget WHERE typ=? GROUP BY category ORDER BY ABS(s) DESC",
                    (typ,),
                )
        elif month is None:
            if typ is None:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget WHERE year=? GROUP BY category ORDER BY ABS(s) DESC",
                    (int(year),),
                )
            else:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget WHERE year=? AND typ=? GROUP BY category ORDER BY ABS(s) DESC",
                    (int(year), typ),
                )
        else:
            if typ is None:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget WHERE year=? AND month=? GROUP BY category ORDER BY ABS(s) DESC",
                    (int(year), int(month)),
                )
            else:
                cur = self.conn.execute(
                    "SELECT category, SUM(amount) AS s FROM budget WHERE year=? AND month=? AND typ=? GROUP BY category ORDER BY ABS(s) DESC",
                    (int(year), int(month), typ),
                )
        result = {}
        for r in cur.fetchall():
            cat = str(r["category"])
            # SCHUTZ: Reservierte Kategorien herausfiltern
            if not self._is_reserved_category(cat):
                result[cat] = float(r["s"] or 0.0)
        return result

    def sum_month_all(self, month: int, typ: str | None = None) -> dict[str,float]:
        if typ is None:
            cur = self.conn.execute(
                "SELECT category, SUM(amount) AS s FROM budget WHERE month=? GROUP BY category ORDER BY ABS(s) DESC",
                (int(month),),
            )
        else:
            cur = self.conn.execute(
                "SELECT category, SUM(amount) AS s FROM budget WHERE month=? AND typ=? GROUP BY category ORDER BY ABS(s) DESC",
                (int(month), typ),
            )
        result = {}
        for r in cur.fetchall():
            cat = str(r["category"])
            # SCHUTZ: Reservierte Kategorien herausfiltern
            if not self._is_reserved_category(cat):
                result[cat] = float(r["s"] or 0.0)
        return result

    def sum_by_month_all(self, typ: str | None = None) -> dict[int, float]:
        if typ is None:
            cur = self.conn.execute("SELECT month AS m, SUM(amount) AS s FROM budget GROUP BY m ORDER BY m")
        else:
            cur = self.conn.execute(
                "SELECT month AS m, SUM(amount) AS s FROM budget WHERE typ=? GROUP BY m ORDER BY m",
                (typ,),
            )
        out = {int(r["m"]): float(r["s"] or 0.0) for r in cur.fetchall()}
        for m in range(1,13):
            out.setdefault(m, 0.0)
        return out

    def copy_year(self, src_year:int, dst_year:int, carry_amounts:bool=True, typ: str | None = None) -> None:
        if typ is None:
            if carry_amounts:
                self.conn.execute(
                    "INSERT OR REPLACE INTO budget(year,month,typ,category,amount) "
                    "SELECT ?, month, typ, category, amount FROM budget WHERE year=? AND category NOT LIKE '%SALDO%'",
                    (int(dst_year), int(src_year)),
                )
            else:
                self.conn.execute(
                    "INSERT OR REPLACE INTO budget(year,month,typ,category,amount) "
                    "SELECT ?, month, typ, category, 0 FROM budget WHERE year=? AND category NOT LIKE '%SALDO%'",
                    (int(dst_year), int(src_year)),
                )
        else:
            if carry_amounts:
                self.conn.execute(
                    "INSERT OR REPLACE INTO budget(year,month,typ,category,amount) "
                    "SELECT ?, month, typ, category, amount FROM budget WHERE year=? AND typ=? AND category NOT LIKE '%SALDO%'",
                    (int(dst_year), int(src_year), typ),
                )
            else:
                self.conn.execute(
                    "INSERT OR REPLACE INTO budget(year,month,typ,category,amount) "
                    "SELECT ?, month, typ, category, 0 FROM budget WHERE year=? AND typ=? AND category NOT LIKE '%SALDO%'",
                    (int(dst_year), int(src_year), typ),
                )
        self.conn.commit()
